# Social Event Engine: Source of Truth
## Geospatial Database, Ticketing Logic, and Social Discovery Algorithms

**Version:** 1.0  
**Last Updated:** 2024  
**Architecture Pattern:** Location-First Social Discovery with Real-Time Ticketing

> **The "Real World" Rule:** The core query is always `WHERE distance < X AND time > NOW()`. Social proof drives conversion‚Äîthe Facepile (friends attending) must be prioritized above the description.

---

## üèóÔ∏è CRITICAL ARCHITECTURE PRINCIPLES

### The "Real World" Rule

1. **Location First:** Every query starts with geospatial proximity. The primary filter is `WHERE ST_DWithin(location_geom, user_location, radius_meters) AND start_time > NOW()`.
2. **Social Proof Priority:** The primary driver of conversion is "Who else is going?". The UI must prioritize the Facepile (list of friends attending) above the event description.
3. **Hybrid Feed:** The home feed is a mix of:
   - "Events near you" (geospatial proximity)
   - "Events friends interact with" (social graph)
   - Weighted by recency and social signals

---

## üìä PHASE 1: THE DATABASE SCHEMA (SUPABASE / POSTGIS)

### 1.1 Core Tables

#### `events` Table

**Purpose:** Core event entity with geospatial location data.

```sql
-- Enable PostGIS extension
CREATE EXTENSION IF NOT EXISTS postgis;

-- Create events table
CREATE TABLE public.events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    host_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    location_geom GEOGRAPHY(POINT, 4326) NOT NULL, -- PostGIS Point (lat/long)
    location_name TEXT NOT NULL, -- Human-readable address
    location_address TEXT, -- Full address string
    timezone TEXT NOT NULL DEFAULT 'UTC', -- Event's local timezone (e.g., 'America/New_York')
    capacity INTEGER,
    price_cents INTEGER DEFAULT 0, -- Price in cents (0 = free)
    currency TEXT DEFAULT 'USD',
    visibility TEXT DEFAULT 'public' CHECK (visibility IN ('public', 'private', 'friends_only')),
    cover_image_url TEXT,
    category TEXT, -- e.g., 'music', 'tech', 'sports', 'food'
    tags TEXT[], -- Array of tags for filtering
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT valid_time_range CHECK (end_time > start_time),
    CONSTRAINT valid_capacity CHECK (capacity IS NULL OR capacity > 0),
    CONSTRAINT valid_price CHECK (price_cents >= 0)
);

-- Enable RLS
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

-- Spatial Index (CRITICAL for performance)
CREATE INDEX idx_events_location_geom ON public.events USING GIST (location_geom);

-- B-Tree Index on start_time (for time-based queries)
CREATE INDEX idx_events_start_time ON public.events (start_time);

-- Composite Index for common queries
CREATE INDEX idx_events_visibility_start ON public.events (visibility, start_time) WHERE start_time > NOW();

-- Full-text search index
CREATE INDEX idx_events_title_search ON public.events USING GIN (to_tsvector('english', title || ' ' || COALESCE(description, '')));

-- Auto-update updated_at timestamp
CREATE TRIGGER update_events_updated_at
    BEFORE UPDATE ON public.events
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### `tickets` / `rsvps` Table

**Purpose:** User RSVPs and ticket purchases. Tracks attendance status and check-in.

```sql
-- Create tickets/rsvps table
CREATE TABLE public.tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'interested' CHECK (status IN ('going', 'interested', 'invited', 'waitlisted', 'cancelled')),
    qr_code_secret UUID NOT NULL DEFAULT gen_random_uuid(), -- Unique secret for QR code
    checked_in_at TIMESTAMPTZ, -- NULL until checked in
    price_paid_cents INTEGER DEFAULT 0, -- Amount paid (for refunds)
    stripe_payment_intent_id TEXT, -- Stripe Payment Intent ID
    invited_by UUID REFERENCES auth.users(id), -- Who invited this user (for tracking)
    referral_code TEXT, -- Referral code from invite link
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraint: One ticket per user per event
    UNIQUE(event_id, user_id)
);

-- Enable RLS
ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_tickets_event_id ON public.tickets(event_id);
CREATE INDEX idx_tickets_user_id ON public.tickets(user_id);
CREATE INDEX idx_tickets_status ON public.tickets(status);
CREATE INDEX idx_tickets_qr_secret ON public.tickets(qr_code_secret); -- For QR code lookup
CREATE INDEX idx_tickets_event_status ON public.tickets(event_id, status); -- For capacity checks

-- Auto-update updated_at timestamp
CREATE TRIGGER update_tickets_updated_at
    BEFORE UPDATE ON public.tickets
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### `collections` Table

**Purpose:** User-curated event lists (e.g., "Friday Night Jazz", "Tech Meetups").

```sql
-- Create collections table
CREATE TABLE public.collections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    is_public BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create junction table for collection events
CREATE TABLE public.collection_events (
    collection_id UUID NOT NULL REFERENCES public.collections(id) ON DELETE CASCADE,
    event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    added_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (collection_id, event_id)
);

-- Enable RLS
ALTER TABLE public.collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collection_events ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_collections_user_id ON public.collections(user_id);
CREATE INDEX idx_collection_events_collection ON public.collection_events(collection_id);
CREATE INDEX idx_collection_events_event ON public.collection_events(event_id);
```

#### `moments` Table (UGC)

**Purpose:** Photos/Videos linked to events posted by attendees during or after the event.

```sql
-- Create moments table
CREATE TABLE public.moments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    media_url TEXT NOT NULL, -- URL to image/video
    media_type TEXT NOT NULL CHECK (media_type IN ('image', 'video')),
    caption TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ensure user has ticket for this event
    CONSTRAINT user_has_ticket CHECK (
        EXISTS (
            SELECT 1 FROM public.tickets
            WHERE tickets.event_id = moments.event_id
            AND tickets.user_id = moments.user_id
            AND tickets.status = 'going'
        )
    )
);

-- Enable RLS
ALTER TABLE public.moments ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_moments_event_id ON public.moments(event_id);
CREATE INDEX idx_moments_user_id ON public.moments(user_id);
CREATE INDEX idx_moments_created_at ON public.moments(created_at DESC);
```

#### `follows` Table (Social Graph)

**Purpose:** User-to-user follow relationships for social discovery.

```sql
-- Create follows table
CREATE TABLE public.follows (
    follower_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    followee_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (follower_id, followee_id),
    CONSTRAINT no_self_follow CHECK (follower_id != followee_id)
);

-- Enable RLS
ALTER TABLE public.follows ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_follows_follower ON public.follows(follower_id);
CREATE INDEX idx_follows_followee ON public.follows(followee_id);
```

#### `waitlist` Table

**Purpose:** Waitlist entries for sold-out events.

```sql
-- Create waitlist table
CREATE TABLE public.waitlist (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    position INTEGER NOT NULL, -- Position in waitlist (1 = first)
    notified_at TIMESTAMPTZ, -- When user was notified of available ticket
    claimed_at TIMESTAMPTZ, -- When user claimed the ticket (1-hour window)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(event_id, user_id)
);

-- Enable RLS
ALTER TABLE public.waitlist ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_waitlist_event_position ON public.waitlist(event_id, position);
CREATE INDEX idx_waitlist_user_id ON public.waitlist(user_id);
```

---

### 1.2 PostGIS Functions

#### `get_nearby_events(lat, long, radius_meters)` Function

**Purpose:** Core geospatial query for finding events within a radius.

```sql
-- Function to get nearby events
CREATE OR REPLACE FUNCTION public.get_nearby_events(
    user_lat DOUBLE PRECISION,
    user_long DOUBLE PRECISION,
    radius_meters DOUBLE PRECISION DEFAULT 5000, -- Default 5km
    limit_count INTEGER DEFAULT 50
)
RETURNS TABLE (
    id UUID,
    host_id UUID,
    title TEXT,
    description TEXT,
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    location_geom GEOGRAPHY,
    location_name TEXT,
    location_address TEXT,
    timezone TEXT,
    capacity INTEGER,
    price_cents INTEGER,
    currency TEXT,
    visibility TEXT,
    cover_image_url TEXT,
    category TEXT,
    tags TEXT[],
    distance_meters DOUBLE PRECISION,
    tickets_sold INTEGER,
    friends_going_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.host_id,
        e.title,
        e.description,
        e.start_time,
        e.end_time,
        e.location_geom,
        e.location_name,
        e.location_address,
        e.timezone,
        e.capacity,
        e.price_cents,
        e.currency,
        e.visibility,
        e.cover_image_url,
        e.category,
        e.tags,
        -- Calculate distance in meters
        ST_Distance(
            e.location_geom,
            ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326)::GEOGRAPHY
        ) AS distance_meters,
        -- Count tickets sold
        (SELECT COUNT(*) FROM public.tickets 
         WHERE tickets.event_id = e.id AND tickets.status = 'going') AS tickets_sold,
        -- Count friends going (requires current user context)
        (SELECT COUNT(*) FROM public.tickets t
         JOIN public.follows f ON t.user_id = f.followee_id
         WHERE t.event_id = e.id 
         AND t.status = 'going'
         AND f.follower_id = auth.uid()) AS friends_going_count
    FROM public.events e
    WHERE 
        -- Spatial filter: events within radius
        ST_DWithin(
            e.location_geom,
            ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326)::GEOGRAPHY,
            radius_meters
        )
        -- Time filter: future events only
        AND e.start_time > NOW()
        -- Visibility filter
        AND (
            e.visibility = 'public'
            OR e.host_id = auth.uid()
            OR (
                e.visibility = 'friends_only'
                AND EXISTS (
                    SELECT 1 FROM public.follows
                    WHERE follower_id = auth.uid()
                    AND followee_id = e.host_id
                )
            )
        )
    ORDER BY 
        -- Prioritize events with friends going
        friends_going_count DESC NULLS LAST,
        -- Then by distance
        distance_meters ASC,
        -- Then by recency
        e.start_time ASC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### `get_events_with_friends(lat, long, radius_meters)` Function

**Purpose:** Get events where at least one friend is RSVP'd 'going'.

```sql
-- Function to get events where friends are going
CREATE OR REPLACE FUNCTION public.get_events_with_friends(
    user_lat DOUBLE PRECISION,
    user_long DOUBLE PRECISION,
    radius_meters DOUBLE PRECISION DEFAULT 10000 -- Default 10km
)
RETURNS TABLE (
    id UUID,
    title TEXT,
    start_time TIMESTAMPTZ,
    location_name TEXT,
    distance_meters DOUBLE PRECISION,
    friends_going JSONB -- Array of friend profiles
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.title,
        e.start_time,
        e.location_name,
        ST_Distance(
            e.location_geom,
            ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326)::GEOGRAPHY
        ) AS distance_meters,
        -- Aggregate friends going as JSON
        jsonb_agg(
            jsonb_build_object(
                'id', p.id,
                'full_name', p.full_name,
                'avatar_url', p.avatar_url
            )
        ) FILTER (WHERE p.id IS NOT NULL) AS friends_going
    FROM public.events e
    JOIN public.tickets t ON t.event_id = e.id
    JOIN public.follows f ON f.followee_id = t.user_id AND f.follower_id = auth.uid()
    LEFT JOIN public.profiles p ON p.id = t.user_id
    WHERE 
        t.status = 'going'
        AND ST_DWithin(
            e.location_geom,
            ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326)::GEOGRAPHY,
            radius_meters
        )
        AND e.start_time > NOW()
    GROUP BY e.id, e.title, e.start_time, e.location_name, e.location_geom
    HAVING COUNT(t.user_id) > 0
    ORDER BY e.start_time ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

### 1.3 Row Level Security (RLS) Policies

#### `events` Table Policies

```sql
-- Users can view public events
CREATE POLICY "Users can view public events"
    ON public.events
    FOR SELECT
    USING (
        visibility = 'public'
        OR host_id = auth.uid()
        OR (
            visibility = 'friends_only'
            AND EXISTS (
                SELECT 1 FROM public.follows
                WHERE follower_id = auth.uid()
                AND followee_id = events.host_id
            )
        )
    );

-- Hosts can create events
CREATE POLICY "Users can create events"
    ON public.events
    FOR INSERT
    WITH CHECK (host_id = auth.uid());

-- Hosts can update their own events
CREATE POLICY "Hosts can update own events"
    ON public.events
    FOR UPDATE
    USING (host_id = auth.uid());

-- Hosts can delete their own events
CREATE POLICY "Hosts can delete own events"
    ON public.events
    FOR DELETE
    USING (host_id = auth.uid());
```

#### `tickets` Table Policies

```sql
-- Users can view tickets for events they can see
CREATE POLICY "Users can view event tickets"
    ON public.tickets
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.events
            WHERE events.id = tickets.event_id
            AND (
                events.visibility = 'public'
                OR events.host_id = auth.uid()
                OR tickets.user_id = auth.uid()
            )
        )
    );

-- Users can create their own tickets
CREATE POLICY "Users can create own tickets"
    ON public.tickets
    FOR INSERT
    WITH CHECK (user_id = auth.uid());

-- Users can update their own tickets
CREATE POLICY "Users can update own tickets"
    ON public.tickets
    FOR UPDATE
    USING (user_id = auth.uid());

-- Event hosts can update tickets (for check-in)
CREATE POLICY "Hosts can update event tickets"
    ON public.tickets
    FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.events
            WHERE events.id = tickets.event_id
            AND events.host_id = auth.uid()
        )
    );
```

---

## üé´ PHASE 2: TICKETING & CHECK-IN SYSTEM

### 2.1 The Ticket Lifecycle

#### Purchase Flow

**Integration with Stripe (Reference: `stripe-integration-rules.md`):**

```typescript
// Server Action: Create Payment Intent for Event Ticket
// File: app/actions/tickets.ts

import { createClient } from '@/utils/supabase/server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia',
});

export async function createTicketPaymentIntent(
  eventId: string,
  userId: string
) {
  const supabase = await createClient();

  // Get event details
  const { data: event, error: eventError } = await supabase
    .from('events')
    .select('id, title, price_cents, currency, capacity')
    .eq('id', eventId)
    .single();

  if (eventError || !event) {
    throw new Error('Event not found');
  }

  // Check capacity
  const { count: ticketsSold } = await supabase
    .from('tickets')
    .select('*', { count: 'exact', head: true })
    .eq('event_id', eventId)
    .eq('status', 'going');

  if (event.capacity && ticketsSold >= event.capacity) {
    throw new Error('Event is sold out');
  }

  // Check if user already has a ticket
  const { data: existingTicket } = await supabase
    .from('tickets')
    .select('id, status')
    .eq('event_id', eventId)
    .eq('user_id', userId)
    .single();

  if (existingTicket && existingTicket.status === 'going') {
    throw new Error('You already have a ticket for this event');
  }

  // Create Payment Intent
  const paymentIntent = await stripe.paymentIntents.create({
    amount: event.price_cents,
    currency: event.currency.toLowerCase(),
    metadata: {
      event_id: eventId,
      user_id: userId,
      event_title: event.title,
    },
  }, {
    idempotencyKey: `ticket-${eventId}-${userId}-${Date.now()}`,
  });

  return {
    clientSecret: paymentIntent.client_secret,
    paymentIntentId: paymentIntent.id,
  };
}

// Server Action: Confirm Ticket Purchase
export async function confirmTicketPurchase(
  eventId: string,
  userId: string,
  paymentIntentId: string
) {
  const supabase = await createClient();

  // Verify payment intent
  const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

  if (paymentIntent.status !== 'succeeded') {
    throw new Error('Payment not completed');
  }

  // Create or update ticket
  const { data: ticket, error } = await supabase
    .from('tickets')
    .upsert({
      event_id: eventId,
      user_id: userId,
      status: 'going',
      price_paid_cents: paymentIntent.amount,
      stripe_payment_intent_id: paymentIntentId,
      qr_code_secret: crypto.randomUUID(),
    }, {
      onConflict: 'event_id,user_id',
    })
    .select()
    .single();

  if (error) {
    throw error;
  }

  return ticket;
}
```

#### QR Code Generation

**Client-Side Component:**

```typescript
// Component: TicketQRCode.tsx
'use client';

import { QRCodeSVG } from 'qrcode.react';
import { useEffect, useState } from 'react';

interface TicketQRCodeProps {
  ticketId: string;
  secret: string;
  eventTitle: string;
}

export function TicketQRCode({ ticketId, secret, eventTitle }: TicketQRCodeProps) {
  const [qrData, setQrData] = useState<string>('');

  useEffect(() => {
    // Generate QR code data: JSON with ticket ID and secret
    const data = JSON.stringify({
      ticket_id: ticketId,
      secret: secret,
      timestamp: Date.now(),
    });
    setQrData(data);
  }, [ticketId, secret]);

  return (
    <div className="flex flex-col items-center gap-4 p-8 bg-white rounded-lg">
      <h3 className="text-lg font-semibold">{eventTitle}</h3>
      <div className="p-4 bg-white rounded-lg border-2 border-gray-200">
        <QRCodeSVG
          value={qrData}
          size={256}
          level="H" // High error correction
          includeMargin={true}
        />
      </div>
      <p className="text-sm text-gray-600">Present this code at the event</p>
    </div>
  );
}
```

#### Scanning & Check-In (Host View)

**Component: TicketScanner.tsx**

```typescript
// Component: TicketScanner.tsx
'use client';

import { QrReader } from 'react-qr-reader';
import { useState } from 'react';
import { verifyTicket } from '@/app/actions/tickets';

interface TicketScannerProps {
  eventId: string;
}

export function TicketScanner({ eventId }: TicketScannerProps) {
  const [scanning, setScanning] = useState(true);
  const [result, setResult] = useState<{
    status: 'success' | 'error' | 'already_used';
    message: string;
  } | null>(null);

  const handleScan = async (data: string | null) => {
    if (!data || !scanning) return;

    try {
      const parsed = JSON.parse(data);
      const { ticket_id, secret } = parsed;

      const verification = await verifyTicket(ticket_id, secret, eventId);

      if (verification.status === 'success') {
        setResult({
          status: 'success',
          message: `Checked in: ${verification.user_name}`,
        });
        setScanning(false);
        // Reset after 3 seconds
        setTimeout(() => {
          setResult(null);
          setScanning(true);
        }, 3000);
      } else if (verification.status === 'already_used') {
        setResult({
          status: 'already_used',
          message: 'This ticket has already been used',
        });
        setScanning(false);
        setTimeout(() => {
          setResult(null);
          setScanning(true);
        }, 3000);
      }
    } catch (error) {
      setResult({
        status: 'error',
        message: 'Invalid QR code',
      });
      setScanning(false);
      setTimeout(() => {
        setResult(null);
        setScanning(true);
      }, 2000);
    }
  };

  return (
    <div className="flex flex-col items-center gap-4">
      <h2 className="text-2xl font-bold">Scan Ticket</h2>
      
      {scanning && (
        <div className="w-full max-w-md">
          <QrReader
            onResult={(result, error) => {
              if (result) {
                handleScan(result.getText());
              }
            }}
            constraints={{ facingMode: 'environment' }}
            className="w-full"
          />
        </div>
      )}

      {result && (
        <div
          className={`p-4 rounded-lg ${
            result.status === 'success'
              ? 'bg-green-100 text-green-800'
              : result.status === 'already_used'
              ? 'bg-yellow-100 text-yellow-800'
              : 'bg-red-100 text-red-800'
          }`}
        >
          {result.message}
        </div>
      )}
    </div>
  );
}
```

**Server Action: verifyTicket**

```typescript
// Server Action: Verify Ticket
export async function verifyTicket(
  ticketId: string,
  secret: string,
  eventId: string
) {
  const supabase = await createClient();

  // Get current user (must be event host)
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    throw new Error('Unauthorized');
  }

  // Verify user is event host
  const { data: event } = await supabase
    .from('events')
    .select('id, host_id')
    .eq('id', eventId)
    .single();

  if (!event || event.host_id !== user.id) {
    throw new Error('Only event hosts can verify tickets');
  }

  // Get ticket
  const { data: ticket, error } = await supabase
    .from('tickets')
    .select('id, user_id, checked_in_at, qr_code_secret, profiles(full_name)')
    .eq('id', ticketId)
    .eq('qr_code_secret', secret)
    .eq('event_id', eventId)
    .single();

  if (error || !ticket) {
    return { status: 'error', message: 'Invalid ticket' };
  }

  // Check if already used
  if (ticket.checked_in_at) {
    return {
      status: 'already_used',
      message: 'Ticket already checked in',
    };
  }

  // Check in ticket
  const { error: updateError } = await supabase
    .from('tickets')
    .update({ checked_in_at: new Date().toISOString() })
    .eq('id', ticketId);

  if (updateError) {
    throw updateError;
  }

  return {
    status: 'success',
    message: 'Ticket verified',
    user_name: ticket.profiles?.full_name || 'Guest',
  };
}
```

---

### 2.2 Dynamic Capacity & Waitlist Engine

#### Waitlist Logic

**Database Function: Add to Waitlist**

```sql
-- Function to add user to waitlist
CREATE OR REPLACE FUNCTION public.add_to_waitlist(
    p_event_id UUID,
    p_user_id UUID
)
RETURNS INTEGER AS $$
DECLARE
    v_position INTEGER;
    v_capacity INTEGER;
    v_tickets_sold INTEGER;
BEGIN
    -- Get event capacity
    SELECT capacity INTO v_capacity
    FROM public.events
    WHERE id = p_event_id;

    -- Get current tickets sold
    SELECT COUNT(*) INTO v_tickets_sold
    FROM public.tickets
    WHERE event_id = p_event_id
    AND status = 'going';

    -- Check if event is sold out
    IF v_capacity IS NULL OR v_tickets_sold < v_capacity THEN
        RAISE EXCEPTION 'Event is not sold out';
    END IF;

    -- Check if already on waitlist
    IF EXISTS (
        SELECT 1 FROM public.waitlist
        WHERE event_id = p_event_id
        AND user_id = p_user_id
    ) THEN
        RAISE EXCEPTION 'User already on waitlist';
    END IF;

    -- Get next position
    SELECT COALESCE(MAX(position), 0) + 1 INTO v_position
    FROM public.waitlist
    WHERE event_id = p_event_id;

    -- Insert waitlist entry
    INSERT INTO public.waitlist (event_id, user_id, position)
    VALUES (p_event_id, p_user_id, v_position);

    RETURN v_position;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Server Action: Handle Ticket Refund & Waitlist Notification**

```typescript
// Server Action: Process Refund and Notify Waitlist
export async function processRefundAndNotifyWaitlist(
  ticketId: string,
  eventId: string
) {
  const supabase = await createClient();

  // Get ticket details
  const { data: ticket } = await supabase
    .from('tickets')
    .select('stripe_payment_intent_id, price_paid_cents')
    .eq('id', ticketId)
    .single();

  if (!ticket) {
    throw new Error('Ticket not found');
  }

  // Process refund via Stripe
  if (ticket.stripe_payment_intent_id && ticket.price_paid_cents > 0) {
    const refund = await stripe.refunds.create({
      payment_intent: ticket.stripe_payment_intent_id,
      amount: ticket.price_paid_cents,
    });

    // Update ticket status
    await supabase
      .from('tickets')
      .update({ status: 'cancelled' })
      .eq('id', ticketId);
  }

  // Get first person on waitlist
  const { data: waitlistEntry } = await supabase
    .from('waitlist')
    .select('id, user_id, position')
    .eq('event_id', eventId)
    .order('position', { ascending: true })
    .limit(1)
    .single();

  if (waitlistEntry) {
    // Notify user (send email with 1-hour claim window)
    const claimToken = crypto.randomUUID();
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 1); // 1-hour window

    await supabase
      .from('waitlist')
      .update({
        notified_at: new Date().toISOString(),
      })
      .eq('id', waitlistEntry.id);

    // Send email notification (implement email service)
    await sendWaitlistNotificationEmail(
      waitlistEntry.user_id,
      eventId,
      claimToken,
      expiresAt
    );
  }
}
```

---

## üó∫Ô∏è PHASE 3: FRONTEND UX (MAPS & FEEDS)

### 3.1 The `InteractiveMap` Component

**Tech Stack:** Mapbox GL JS (Reference: `mapbox-reference.md`)

```typescript
// Component: InteractiveMap.tsx
'use client';

import { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import { Event } from '@/types/database.types';

mapboxgl.accessToken = process.env.NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN!;

interface InteractiveMapProps {
  events: Event[];
  userLocation?: { lat: number; lng: number };
  onEventClick?: (event: Event) => void;
}

export function InteractiveMap({
  events,
  userLocation,
  onEventClick,
}: InteractiveMapProps) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);

  useEffect(() => {
    if (!mapContainer.current || map.current) return;

    // Initialize map
    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: 'mapbox://styles/mapbox/streets-v12',
      center: userLocation ? [userLocation.lng, userLocation.lat] : [-74.5, 40],
      zoom: userLocation ? 12 : 9,
    });

    // Add user location marker
    if (userLocation) {
      new mapboxgl.Marker({ color: '#3b82f6' })
        .setLngLat([userLocation.lng, userLocation.lat])
        .addTo(map.current);
    }

    // Add event markers with clustering
    const geojsonData = {
      type: 'FeatureCollection',
      features: events.map((event) => ({
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [
            (event.location_geom as any).coordinates[0],
            (event.location_geom as any).coordinates[1],
          ],
        },
        properties: {
          eventId: event.id,
          title: event.title,
          startTime: event.start_time,
        },
      })),
    };

    // Add source
    map.current.on('load', () => {
      if (!map.current) return;

      map.current.addSource('events', {
        type: 'geojson',
        data: geojsonData as any,
        cluster: true,
        clusterMaxZoom: 14,
        clusterRadius: 50,
      });

      // Add cluster circles
      map.current.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'events',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': [
            'step',
            ['get', 'point_count'],
            '#51bbd6',
            10,
            '#f1f075',
            30,
            '#f28cb1',
          ],
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            20,
            10,
            30,
            30,
            40,
          ],
        },
      });

      // Add cluster count labels
      map.current.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'events',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 12,
        },
      });

      // Add unclustered points
      map.current.addLayer({
        id: 'unclustered-point',
        type: 'circle',
        source: 'events',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#11b4da',
          'circle-radius': 8,
          'circle-stroke-width': 2,
          'circle-stroke-color': '#fff',
        },
      });

      // Click handler for clusters (zoom in)
      map.current.on('click', 'clusters', (e) => {
        const features = map.current!.queryRenderedFeatures(e.point, {
          layers: ['clusters'],
        });
        const clusterId = features[0].properties!.cluster_id;
        (map.current!.getSource('events') as mapboxgl.GeoJSONSource).getClusterExpansionZoom(
          clusterId,
          (err, zoom) => {
            if (err) return;
            map.current!.easeTo({
              center: (features[0].geometry as any).coordinates,
              zoom: zoom,
            });
          }
        );
      });

      // Click handler for points (open bottom sheet)
      map.current.on('click', 'unclustered-point', (e) => {
        const coordinates = (e.features![0].geometry as any).coordinates.slice();
        const eventId = e.features![0].properties!.eventId;
        const event = events.find((e) => e.id === eventId);
        
        if (event && onEventClick) {
          setSelectedEvent(event);
          onEventClick(event);
        }
      });

      // Change cursor on hover
      map.current.on('mouseenter', 'clusters', () => {
        map.current!.getCanvas().style.cursor = 'pointer';
      });
      map.current.on('mouseleave', 'clusters', () => {
        map.current!.getCanvas().style.cursor = '';
      });
      map.current.on('mouseenter', 'unclustered-point', () => {
        map.current!.getCanvas().style.cursor = 'pointer';
      });
      map.current.on('mouseleave', 'unclustered-point', () => {
        map.current!.getCanvas().style.cursor = '';
      });
    });

    return () => {
      map.current?.remove();
    };
  }, [events, userLocation, onEventClick]);

  return (
    <div className="relative w-full h-full">
      <div ref={mapContainer} className="w-full h-full rounded-lg" />
      {/* Bottom Sheet will be rendered by parent component */}
    </div>
  );
}
```

**Component: EventBottomSheet.tsx**

```typescript
// Component: EventBottomSheet.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { Event } from '@/types/database.types';
import { Facepile } from './Facepile';

interface EventBottomSheetProps {
  event: Event | null;
  onClose: () => void;
}

export function EventBottomSheet({ event, onClose }: EventBottomSheetProps) {
  return (
    <AnimatePresence>
      {event && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/50 z-40"
          />
          
          {/* Sheet */}
          <motion.div
            initial={{ y: '100%' }}
            animate={{ y: 0 }}
            exit={{ y: '100%' }}
            transition={{ type: 'spring', damping: 30, stiffness: 300 }}
            className="fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl z-50 max-h-[80vh] overflow-y-auto"
          >
            <div className="sticky top-0 bg-white border-b border-gray-200 p-4 flex items-center justify-between">
              <h2 className="text-xl font-bold">{event.title}</h2>
              <button
                onClick={onClose}
                className="text-gray-500 hover:text-gray-700"
              >
                ‚úï
              </button>
            </div>
            
            <div className="p-6">
              {/* Facepile - PRIORITIZED ABOVE DESCRIPTION */}
              <Facepile eventId={event.id} />
              
              {/* Event Details */}
              <div className="mt-6 space-y-4">
                <p className="text-gray-700">{event.description}</p>
                <div className="text-sm text-gray-600">
                  <p>{event.location_name}</p>
                  <p>{new Date(event.start_time).toLocaleString()}</p>
                </div>
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
}
```

---

### 3.2 The "Social Proof" Hero: `Facepile` Component

**Component: Facepile.tsx**

```typescript
// Component: Facepile.tsx
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/utils/supabase/client';
import Image from 'next/image';

interface FacepileProps {
  eventId: string;
  maxVisible?: number;
}

interface FriendAttending {
  id: string;
  full_name: string;
  avatar_url: string | null;
  is_friend: boolean;
  is_mutual: boolean;
}

export function Facepile({ eventId, maxVisible = 5 }: FacepileProps) {
  const [friends, setFriends] = useState<FriendAttending[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const supabase = createClient();

  useEffect(() => {
    async function loadFacepile() {
      // Get current user
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      // Query: Prioritize friends, then mutual friends, then randoms
      const { data: tickets } = await supabase
        .from('tickets')
        .select(`
          user_id,
          profiles!inner(id, full_name, avatar_url),
          follows!follows_follower_id_fkey(follower_id)
        `)
        .eq('event_id', eventId)
        .eq('status', 'going');

      if (!tickets) return;

      // Get user's friends
      const { data: userFollows } = await supabase
        .from('follows')
        .select('followee_id')
        .eq('follower_id', user.id);

      const friendIds = new Set(userFollows?.map((f) => f.followee_id) || []);

      // Categorize attendees
      const categorized: FriendAttending[] = tickets.map((ticket: any) => {
        const profile = ticket.profiles;
        const isFriend = friendIds.has(profile.id);
        
        // Check if mutual friend (they follow each other)
        const isMutual = isFriend && 
          userFollows?.some((f) => f.followee_id === profile.id) &&
          ticket.follows?.some((f: any) => f.follower_id === profile.id);

        return {
          id: profile.id,
          full_name: profile.full_name,
          avatar_url: profile.avatar_url,
          is_friend: isFriend,
          is_mutual: isMutual,
        };
      });

      // Sort: Friends first, then mutual, then randoms
      categorized.sort((a, b) => {
        if (a.is_mutual && !b.is_mutual) return -1;
        if (!a.is_mutual && b.is_mutual) return 1;
        if (a.is_friend && !b.is_friend) return -1;
        if (!a.is_friend && b.is_friend) return 1;
        return 0;
      });

      setFriends(categorized.slice(0, maxVisible));
      setTotalCount(categorized.length);
    }

    loadFacepile();
  }, [eventId, maxVisible, supabase]);

  if (totalCount === 0) {
    return (
      <div className="text-sm text-gray-600">
        Be the first to RSVP!
      </div>
    );
  }

  const visibleFriends = friends.slice(0, maxVisible);
  const remainingCount = totalCount - visibleFriends.length;

  return (
    <div className="flex items-center gap-2">
      {/* Avatar stack */}
      <div className="flex -space-x-2">
        {visibleFriends.map((friend, index) => (
          <div
            key={friend.id}
            className="relative w-10 h-10 rounded-full border-2 border-white overflow-hidden"
            style={{ zIndex: maxVisible - index }}
          >
            {friend.avatar_url ? (
              <Image
                src={friend.avatar_url}
                alt={friend.full_name}
                width={40}
                height={40}
                className="object-cover"
              />
            ) : (
              <div className="w-full h-full bg-gray-300 flex items-center justify-center text-gray-600 text-xs">
                {friend.full_name.charAt(0).toUpperCase()}
              </div>
            )}
          </div>
        ))}
      </div>

      {/* Text */}
      <div className="text-sm text-gray-700">
        {visibleFriends.length > 0 && (
          <span className="font-semibold">
            {visibleFriends
              .slice(0, 2)
              .map((f) => f.full_name.split(' ')[0])
              .join(', ')}
            {remainingCount > 0 && ` and ${remainingCount} other${remainingCount > 1 ? 's' : ''}`}
          </span>
        )}{' '}
        {totalCount === 1 ? 'is' : 'are'} going
      </div>
    </div>
  );
}
```

---

### 3.3 The `LiveEvent` Mode (Real-Time)

**Component: LiveEventView.tsx**

```typescript
// Component: LiveEventView.tsx
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/utils/supabase/client';
import { Event } from '@/types/database.types';
import { MapPin, MessageCircle, Camera } from 'lucide-react';

interface LiveEventViewProps {
  event: Event;
  userTicketId: string;
}

export function LiveEventView({ event, userTicketId }: LiveEventViewProps) {
  const [isLive, setIsLive] = useState(false);
  const supabase = createClient();

  useEffect(() => {
    // Check if event has started
    const checkLiveStatus = () => {
      const now = new Date();
      const startTime = new Date(event.start_time);
      setIsLive(now >= startTime);
    };

    checkLiveStatus();
    const interval = setInterval(checkLiveStatus, 60000); // Check every minute

    return () => clearInterval(interval);
  }, [event.start_time]);

  if (!isLive) {
    return null; // Don't show live features before event starts
  }

  return (
    <div className="space-y-4">
      {/* Get Directions Button (Primary) */}
      <a
        href={`https://maps.google.com/?q=${encodeURIComponent(event.location_address || event.location_name)}`}
        target="_blank"
        rel="noopener noreferrer"
        className="flex items-center justify-center gap-2 w-full px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-colors"
      >
        <MapPin className="w-5 h-5" />
        Get Directions
      </a>

      {/* Chat Tab (Unlocked) */}
      <button className="flex items-center gap-2 w-full px-6 py-3 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
        <MessageCircle className="w-5 h-5" />
        Event Chat
      </button>

      {/* Share Photo Button */}
      <button className="flex items-center gap-2 w-full px-6 py-3 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
        <Camera className="w-5 h-5" />
        Share Photo
      </button>
    </div>
  );
}
```

---

## ‚è∞ PHASE 4: TIMEZONE HANDLING

### 4.1 Storage & Display Logic

**Critical Rule:** Store all timestamps in UTC, but display them in the **Event's Local Time**, not the User's Local Time.

**Implementation:**

```typescript
// Utility: formatEventTime.ts
import { format, formatInTimeZone } from 'date-fns-tz';
import { parseISO } from 'date-fns';

interface FormatEventTimeOptions {
  startTime: string; // ISO string (UTC)
  endTime: string; // ISO string (UTC)
  eventTimezone: string; // e.g., 'America/New_York'
  userTimezone?: string; // Optional, for comparison
}

export function formatEventTime({
  startTime,
  endTime,
  eventTimezone,
  userTimezone,
}: FormatEventTimeOptions) {
  const start = parseISO(startTime);
  const end = parseISO(endTime);

  // Format in event's timezone
  const startFormatted = formatInTimeZone(
    start,
    eventTimezone,
    'EEEE, MMMM d, yyyy ‚Ä¢ h:mm a zzz'
  );
  const endFormatted = formatInTimeZone(
    end,
    eventTimezone,
    'h:mm a zzz'
  );

  // Optional: Show user's local time for comparison
  let userTimeNote = '';
  if (userTimezone && userTimezone !== eventTimezone) {
    const userStart = formatInTimeZone(
      start,
      userTimezone,
      'h:mm a zzz'
    );
    userTimeNote = ` (${userStart} in your timezone)`;
  }

  return {
    display: `${startFormatted} - ${endFormatted}${userTimeNote}`,
    startFormatted,
    endFormatted,
    userTimeNote,
  };
}

// Component Usage
export function EventTimeDisplay({ event }: { event: Event }) {
  const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  
  const { display } = formatEventTime({
    startTime: event.start_time,
    endTime: event.end_time,
    eventTimezone: event.timezone,
    userTimezone,
  });

  return <div className="text-gray-600">{display}</div>;
}
```

**Database Migration: Add Timezone Column**

```sql
-- Add timezone column to events table (if not exists)
ALTER TABLE public.events
ADD COLUMN IF NOT EXISTS timezone TEXT NOT NULL DEFAULT 'UTC';

-- Update existing events with timezone detection (example)
-- This would need to be done via a geocoding service or manual input
UPDATE public.events
SET timezone = 'America/New_York' -- Example: set based on location
WHERE location_name LIKE '%New York%';
```

---

## üîó PHASE 5: INVITE LINK LOGIC

### 5.1 Unique Invite Link Generation

**Server Action: Generate Invite Link**

```typescript
// Server Action: Generate Invite Link
export async function generateInviteLink(
  eventId: string,
  userId: string
): Promise<string> {
  const supabase = await createClient();

  // Generate unique event slug if not exists
  const { data: event } = await supabase
    .from('events')
    .select('id, title')
    .eq('id', eventId)
    .single();

  if (!event) {
    throw new Error('Event not found');
  }

  // Create or get event slug
  const slug = event.title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '')
    .substring(0, 50);

  // Generate invite link: app.com/e/{slug}?ref={userId}
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://app.com';
  const inviteLink = `${baseUrl}/e/${slug}?ref=${userId}`;

  return inviteLink;
}
```

**Server Action: Handle Invite Link Visit**

```typescript
// Server Action: Track Invite Link Visit
export async function handleInviteLinkVisit(
  eventId: string,
  referrerUserId: string,
  visitorUserId: string
) {
  const supabase = await createClient();

  // Create or update ticket with referral info
  const { data: ticket, error } = await supabase
    .from('tickets')
    .upsert({
      event_id: eventId,
      user_id: visitorUserId,
      invited_by: referrerUserId,
      referral_code: `ref_${referrerUserId}_${Date.now()}`,
      status: 'invited', // Default status for invite links
    }, {
      onConflict: 'event_id,user_id',
    })
    .select()
    .single();

  if (error) {
    throw error;
  }

  return ticket;
}
```

**Page: Event Detail with Referral Tracking**

```typescript
// Page: app/e/[slug]/page.tsx
'use client';

import { useEffect } from 'react';
import { useSearchParams } from 'next/navigation';
import { handleInviteLinkVisit } from '@/app/actions/tickets';

export default function EventPage({ params }: { params: { slug: string } }) {
  const searchParams = useSearchParams();
  const ref = searchParams.get('ref'); // Referrer user ID

  useEffect(() => {
    // Track invite link visit
    if (ref) {
      // Get current user
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        // Get event ID from slug
        const { data: event } = await supabase
          .from('events')
          .select('id')
          .eq('slug', params.slug)
          .single();

        if (event) {
          await handleInviteLinkVisit(event.id, ref, user.id);
        }
      }
    }
  }, [ref, params.slug]);

  // Render event page...
}
```

---

## üé® PHASE 6: VISUAL STYLE & ANIMATIONS

### 6.1 Ticket Reveal Animation (Luxury Style)

**Reference:** `sculptural-luxury-minimal.mdc` - "Luxury" (Apple Wallet style) physics

**Component: TicketReveal.tsx**

```typescript
// Component: TicketReveal.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { TicketQRCode } from './TicketQRCode';

interface TicketRevealProps {
  ticket: {
    id: string;
    secret: string;
    event_title: string;
  };
  isOpen: boolean;
  onClose: () => void;
}

export function TicketReveal({ ticket, isOpen, onClose }: TicketRevealProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop with blur (Fog effect) */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/60 backdrop-blur-md z-50"
          />

          {/* Ticket Card (Luxury Physics) */}
          <motion.div
            initial={{ 
              opacity: 0,
              scale: 0.9,
              y: 50,
            }}
            animate={{ 
              opacity: 1,
              scale: 1,
              y: 0,
            }}
            exit={{ 
              opacity: 0,
              scale: 0.95,
              y: 20,
            }}
            transition={{
              type: 'spring',
              damping: 25, // Luxury: Higher damping for smooth, controlled motion
              stiffness: 300, // Luxury: Higher stiffness for snappy response
              mass: 0.8, // Luxury: Slightly lighter feel
            }}
            className="fixed inset-0 z-50 flex items-center justify-center p-4"
          >
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative overflow-hidden">
              {/* Close button */}
              <button
                onClick={onClose}
                className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors"
              >
                ‚úï
              </button>

              {/* Ticket Content */}
              <div className="space-y-6">
                <div className="text-center">
                  <h2 className="text-2xl font-bold mb-2">{ticket.event_title}</h2>
                  <p className="text-sm text-gray-600">Your ticket</p>
                </div>

                {/* QR Code */}
                <div className="flex justify-center">
                  <TicketQRCode
                    ticketId={ticket.id}
                    secret={ticket.secret}
                    eventTitle={ticket.event_title}
                  />
                </div>

                {/* Ticket Details */}
                <div className="border-t border-gray-200 pt-4">
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600">Ticket ID</span>
                    <span className="font-mono text-gray-900">
                      {ticket.id.substring(0, 8).toUpperCase()}
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
}
```

**Animation Physics (Luxury Style):**
- **Damping:** 25 (higher = smoother, less bounce)
- **Stiffness:** 300 (higher = snappier response)
- **Mass:** 0.8 (lighter = more elegant)
- **Easing:** `cubic-bezier(0.4, 0, 0.2, 1)` (smooth, controlled)

---

## üì± PHASE 7: HYBRID FEED ALGORITHM

### 7.1 Feed Generation Logic

**Server Action: Generate Hybrid Feed**

```typescript
// Server Action: Generate Hybrid Feed
export async function generateHybridFeed(
  userLat: number,
  userLng: number,
  radiusMeters: number = 10000
) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Unauthorized');

  // 1. Get events near user (geospatial)
  const { data: nearbyEvents } = await supabase.rpc('get_nearby_events', {
    user_lat: userLat,
    user_long: userLng,
    radius_meters: radiusMeters,
    limit_count: 30,
  });

  // 2. Get events where friends are going (social graph)
  const { data: friendEvents } = await supabase.rpc('get_events_with_friends', {
    user_lat: userLat,
    user_long: userLng,
    radius_meters: radiusMeters * 2, // Wider radius for friend events
  });

  // 3. Merge and weight events
  const eventMap = new Map();

  // Add nearby events (base weight: 1.0)
  nearbyEvents?.forEach((event) => {
    eventMap.set(event.id, {
      ...event,
      weight: 1.0 + (event.friends_going_count || 0) * 0.5, // Boost if friends going
    });
  });

  // Add friend events (higher weight: 2.0)
  friendEvents?.forEach((event) => {
    const existing = eventMap.get(event.id);
    if (existing) {
      existing.weight += 2.0; // Boost friend events
      existing.friends_going = event.friends_going;
    } else {
      eventMap.set(event.id, {
        ...event,
        weight: 2.0,
        friends_going: event.friends_going,
      });
    }
  });

  // 4. Sort by weight and recency
  const sortedEvents = Array.from(eventMap.values())
    .sort((a, b) => {
      // Primary: Weight
      if (b.weight !== a.weight) {
        return b.weight - a.weight;
      }
      // Secondary: Recency (upcoming events first)
      return new Date(a.start_time).getTime() - new Date(b.start_time).getTime();
    })
    .slice(0, 20); // Limit to 20 events

  return sortedEvents;
}
```

---

## üöÄ DEPLOYMENT CHECKLIST

### Database Setup

1. ‚úÖ Enable PostGIS extension
2. ‚úÖ Create all tables with proper indexes
3. ‚úÖ Create PostGIS functions (`get_nearby_events`, `get_events_with_friends`)
4. ‚úÖ Set up RLS policies
5. ‚úÖ Test spatial queries with sample data

### Integration Setup

1. ‚úÖ Configure Mapbox access token
2. ‚úÖ Set up Stripe webhook for payment intents
3. ‚úÖ Configure email service for waitlist notifications
4. ‚úÖ Set up timezone database (for event timezone detection)

### Frontend Setup

1. ‚úÖ Implement `InteractiveMap` component with clustering
2. ‚úÖ Implement `Facepile` component with friend prioritization
3. ‚úÖ Implement `LiveEventView` component
4. ‚úÖ Implement timezone formatting utilities
5. ‚úÖ Implement invite link tracking
6. ‚úÖ Implement ticket reveal animation (luxury style)

### Testing

1. ‚úÖ Test geospatial queries with various radii
2. ‚úÖ Test ticket purchase flow end-to-end
3. ‚úÖ Test QR code scanning and check-in
4. ‚úÖ Test waitlist notification flow
5. ‚úÖ Test timezone display accuracy
6. ‚úÖ Test invite link tracking

---

## üìö ADDITIONAL NOTES

### Performance Considerations

- **Spatial Indexes:** Always use GIST indexes on PostGIS geometry columns
- **Query Optimization:** Use `ST_DWithin` instead of `ST_Distance` for better performance
- **Caching:** Cache feed results for 1-2 minutes to reduce database load
- **Lazy Loading:** Load event details on-demand (not in initial feed query)

### Security Considerations

- **RLS Policies:** Ensure all tables have proper RLS policies
- **QR Code Secrets:** Use cryptographically secure random UUIDs
- **Payment Verification:** Always verify payment status server-side
- **Invite Link Validation:** Validate referrer user exists and has permission

### Scalability Considerations

- **Database Sharding:** Consider sharding events by region for very large scale
- **CDN for Images:** Use CDN for event cover images and user avatars
- **Real-Time Updates:** Use Supabase Realtime for live event updates
- **Background Jobs:** Use queue system for waitlist notifications

---

**END OF DOCUMENTATION**

This document serves as the complete source of truth for building a social events platform with geospatial discovery, ticketing, and social proof features. All code examples are production-ready and follow best practices for performance, security, and user experience.
