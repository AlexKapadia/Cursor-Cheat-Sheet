# Supabase Backend Architecture: Flexible Multi-Tenancy Source of Truth

**Version:** 1.0  
**Last Updated:** 2024  
**Architecture Pattern:** Flexible Multi-Tenancy with Row Level Security

---

## üèóÔ∏è ARCHITECTURAL PRINCIPLES

### The "Flexible Ownership" Rule

1. **Flexible Data Ownership:** Data can be owned by **individual users** OR **organizations**. Use `org_id = NULL` for user-owned data (shops, personal apps), and `org_id IS NOT NULL` for organization-owned data (team SaaS).
2. **RLS is Mandatory:** No query should ever run without Row Level Security enabled. RLS policies support both ownership patterns:
   - **User-Owned:** `org_id IS NULL AND user_id = auth.uid()`
   - **Organization-Owned:** `org_id IS NOT NULL AND is_org_member(org_id)`
3. **Tiered Limits Enforcement:** Feature gating (e.g., "Free plan = 5 projects") must be enforced at the Database level or API level, not just the UI. Limits can apply to users or organizations depending on your model.

---

## üìä PHASE 1: DATABASE SCHEMA (PostgreSQL)

### 1.1 Identity & Structure Tables

#### `profiles` Table

**Purpose:** User profile information linked 1-to-1 with `auth.users`.

```sql
-- Create profiles table
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    avatar_url TEXT,
    onboarding_status TEXT DEFAULT 'pending' CHECK (onboarding_status IN ('pending', 'completed')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Index for performance
CREATE INDEX idx_profiles_id ON public.profiles(id);

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### `organizations` Table

**Purpose:** Optional tenant entity for team collaboration. Only create organizations when users need to share resources or collaborate. For individual shops or personal apps, users can own data directly without organizations.

```sql
-- Create organizations table
CREATE TABLE public.organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    slug TEXT UNIQUE NOT NULL,
    stripe_customer_id TEXT UNIQUE,
    subscription_tier TEXT DEFAULT 'free' CHECK (subscription_tier IN ('free', 'pro', 'enterprise')),
    subscription_status TEXT DEFAULT 'active' CHECK (subscription_status IN ('active', 'canceled', 'past_due', 'trialing')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_organizations_slug ON public.organizations(slug);
CREATE INDEX idx_organizations_stripe_customer_id ON public.organizations(stripe_customer_id);

-- Auto-update updated_at timestamp
CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON public.organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### `memberships` Table

**Purpose:** The many-to-many relationship between users and organizations. Defines user roles within each organization.

```sql
-- Create memberships table
CREATE TABLE public.memberships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    org_id UUID NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
    role TEXT NOT NULL DEFAULT 'member' CHECK (role IN ('owner', 'admin', 'member')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, org_id)
);

-- Enable RLS
ALTER TABLE public.memberships ENABLE ROW LEVEL SECURITY;

-- Indexes for performance
CREATE INDEX idx_memberships_user_id ON public.memberships(user_id);
CREATE INDEX idx_memberships_org_id ON public.memberships(org_id);
CREATE INDEX idx_memberships_user_org ON public.memberships(user_id, org_id);

-- Auto-update updated_at timestamp
CREATE TRIGGER update_memberships_updated_at
    BEFORE UPDATE ON public.memberships
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 1.2 Business Logic Tables

#### `usage_limits` Table

**Purpose:** Defines feature limits for each subscription tier.

```sql
-- Create usage_limits table
CREATE TABLE public.usage_limits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tier_id TEXT UNIQUE NOT NULL CHECK (tier_id IN ('free', 'pro', 'enterprise')),
    max_projects INTEGER NOT NULL DEFAULT 0,
    max_storage_bytes BIGINT NOT NULL DEFAULT 0,
    can_invite_members BOOLEAN DEFAULT FALSE,
    max_members INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Disable RLS (this is a system table, readable by all authenticated users)
ALTER TABLE public.usage_limits ENABLE ROW LEVEL SECURITY;

-- Insert default limits
INSERT INTO public.usage_limits (tier_id, max_projects, max_storage_bytes, can_invite_members, max_members) VALUES
    ('free', 5, 1073741824, FALSE, 1),           -- 1GB storage
    ('pro', 50, 10737418240, TRUE, 10),          -- 10GB storage
    ('enterprise', -1, -1, TRUE, -1);            -- -1 means unlimited

-- Auto-update updated_at timestamp
CREATE TRIGGER update_usage_limits_updated_at
    BEFORE UPDATE ON public.usage_limits
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### `projects` Table (Example Resource)

**Purpose:** Example resource table demonstrating flexible ownership pattern. Supports both user-owned (`org_id = NULL`) and organization-owned (`org_id IS NOT NULL`) data.

```sql
-- Create projects table
CREATE TABLE public.projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    org_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deleted')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Ensure either user owns directly OR org owns (not both, not neither)
    CONSTRAINT ownership_check CHECK (
        (org_id IS NULL AND user_id IS NOT NULL) OR
        (org_id IS NOT NULL)
    )
);

-- Enable RLS
ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_projects_user_id ON public.projects(user_id);
CREATE INDEX idx_projects_org_id ON public.projects(org_id) WHERE org_id IS NOT NULL;
CREATE INDEX idx_projects_status ON public.projects(status);
CREATE INDEX idx_projects_user_org ON public.projects(user_id, org_id);

-- Auto-update updated_at timestamp
CREATE TRIGGER update_projects_updated_at
    BEFORE UPDATE ON public.projects
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### `invitations` Table

**Purpose:** Manages user invitations to organizations.

```sql
-- Create invitations table
CREATE TABLE public.invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'member' CHECK (role IN ('owner', 'admin', 'member')),
    invited_by UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    token TEXT UNIQUE NOT NULL DEFAULT gen_random_uuid()::TEXT,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'expired', 'revoked')),
    expires_at TIMESTAMPTZ DEFAULT (NOW() + INTERVAL '7 days'),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(org_id, email, status) DEFERRABLE INITIALLY DEFERRED
);

-- Enable RLS
ALTER TABLE public.invitations ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_invitations_org_id ON public.invitations(org_id);
CREATE INDEX idx_invitations_email ON public.invitations(email);
CREATE INDEX idx_invitations_token ON public.invitations(token);
CREATE INDEX idx_invitations_status ON public.invitations(status);

-- Auto-update updated_at timestamp
CREATE TRIGGER update_invitations_updated_at
    BEFORE UPDATE ON public.invitations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## üîê PHASE 2: AUTHENTICATION & ONBOARDING

### 2.1 Automatic Profile Creation Trigger

**Purpose:** Automatically create a profile when a new user signs up via Supabase Auth.

```sql
-- Function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Create profile only (no automatic organization creation)
    -- Organizations should be created explicitly when needed (e.g., user opts in during onboarding)
    INSERT INTO public.profiles (id, full_name, onboarding_status)
    VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
        'pending'
    );

    -- NOTE: Organizations are NOT auto-created. Users can create them later if needed.
    -- For apps that require organizations, create them in your onboarding flow.
    -- For individual shops/personal apps, users can work without organizations.

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger on auth.users insert
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();
```

### 2.2 Platform Switching Logic

**Frontend Hook Pattern:** `useCurrentOrganization()`

```typescript
// TypeScript: useCurrentOrganization Hook Pattern
// This should be implemented in your frontend application

import { useState, useEffect } from 'react';
import { useSupabaseClient, useUser } from '@supabase/auth-helpers-react';

interface CurrentOrganizationContext {
  organization: Organization | null;
  setActiveOrganization: (orgId: string) => void;
  isLoading: boolean;
}

// Storage key for persisting active organization
const ACTIVE_ORG_KEY = 'active_org_id';

export function useCurrentOrganization(): CurrentOrganizationContext {
  const supabase = useSupabaseClient();
  const user = useUser();
  const [organization, setOrganization] = useState<Organization | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setIsLoading(false);
      return;
    }

    // Check localStorage for persisted org
    const persistedOrgId = localStorage.getItem(ACTIVE_ORG_KEY);
    
    if (persistedOrgId) {
      loadOrganization(persistedOrgId);
    } else {
      // Load user's first organization (or default)
      loadUserOrganizations();
    }
  }, [user]);

  const loadOrganization = async (orgId: string) => {
    const { data, error } = await supabase
      .from('organizations')
      .select('*')
      .eq('id', orgId)
      .single();

    if (!error && data) {
      setOrganization(data);
      localStorage.setItem(ACTIVE_ORG_KEY, orgId);
    }
    setIsLoading(false);
  };

  const loadUserOrganizations = async () => {
    const { data: memberships } = await supabase
      .from('memberships')
      .select('org_id, organizations(*)')
      .eq('user_id', user.id)
      .limit(1)
      .single();

    if (memberships?.organizations) {
      const org = memberships.organizations as Organization;
      setOrganization(org);
      localStorage.setItem(ACTIVE_ORG_KEY, org.id);
    }
    setIsLoading(false);
  };

  const setActiveOrganization = (orgId: string) => {
    loadOrganization(orgId);
  };

  return { organization, setActiveOrganization, isLoading };
}

// CRITICAL: Filter queries based on ownership pattern
// For organization-owned resources:
// const { data } = await supabase
//   .from('projects')
//   .select('*')
//   .eq('org_id', activeOrgId); // Filter by org_id
//
// For user-owned resources (org_id = NULL):
// const { data } = await supabase
//   .from('projects')
//   .select('*')
//   .is('org_id', null)
//   .eq('user_id', userId); // Filter by user_id
//
// For hybrid (both patterns):
// const { data } = await supabase
//   .from('projects')
//   .select('*')
//   .or(`org_id.eq.${activeOrgId},and(org_id.is.null,user_id.eq.${userId})`);
```

---

## üõ°Ô∏è PHASE 3: ROW LEVEL SECURITY (RLS) POLICIES

### 3.1 Core Helper Functions

#### `is_org_member(org_id)` Function

**Purpose:** Generic function to check if the current user is a member of an organization.

```sql
-- Function to check organization membership
CREATE OR REPLACE FUNCTION public.is_org_member(org_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.memberships
        WHERE user_id = auth.uid()
        AND org_id = is_org_member.org_id
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### `get_user_org_role(org_id)` Function

**Purpose:** Get the current user's role in a specific organization.

```sql
-- Function to get user's role in an organization
CREATE OR REPLACE FUNCTION public.get_user_org_role(org_id UUID)
RETURNS TEXT AS $$
BEGIN
    RETURN (
        SELECT role
        FROM public.memberships
        WHERE user_id = auth.uid()
        AND org_id = get_user_org_role.org_id
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### `is_org_admin_or_owner(org_id)` Function

**Purpose:** Check if the current user has admin or owner privileges.

```sql
-- Function to check if user is admin or owner
CREATE OR REPLACE FUNCTION public.is_org_admin_or_owner(org_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.memberships
        WHERE user_id = auth.uid()
        AND org_id = is_org_admin_or_owner.org_id
        AND role IN ('admin', 'owner')
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3.2 RLS Policies by Table

#### `profiles` Table Policies

```sql
-- Users can read their own profile
CREATE POLICY "Users can view own profile"
    ON public.profiles
    FOR SELECT
    USING (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile"
    ON public.profiles
    FOR UPDATE
    USING (auth.uid() = id);

-- Users can view profiles of members in their organizations
CREATE POLICY "Users can view org member profiles"
    ON public.profiles
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM public.memberships m1
            JOIN public.memberships m2 ON m1.org_id = m2.org_id
            WHERE m1.user_id = auth.uid()
            AND m2.user_id = profiles.id
        )
    );
```

#### `organizations` Table Policies

```sql
-- Users can view organizations they are members of
CREATE POLICY "Users can view own organizations"
    ON public.organizations
    FOR SELECT
    USING (public.is_org_member(id));

-- Only owners can update organization details
CREATE POLICY "Owners can update organizations"
    ON public.organizations
    FOR UPDATE
    USING (public.get_user_org_role(id) = 'owner');

-- Only owners can delete organizations
CREATE POLICY "Owners can delete organizations"
    ON public.organizations
    FOR DELETE
    USING (public.get_user_org_role(id) = 'owner');
```

#### `memberships` Table Policies

```sql
-- Users can view memberships in organizations they belong to
CREATE POLICY "Users can view org memberships"
    ON public.memberships
    FOR SELECT
    USING (public.is_org_member(org_id));

-- Only admins/owners can insert new memberships
CREATE POLICY "Admins can add members"
    ON public.memberships
    FOR INSERT
    WITH CHECK (public.is_org_admin_or_owner(org_id));

-- Only owners can update memberships (role changes)
CREATE POLICY "Owners can update memberships"
    ON public.memberships
    FOR UPDATE
    USING (public.get_user_org_role(org_id) = 'owner');

-- Only owners can remove memberships
CREATE POLICY "Owners can remove memberships"
    ON public.memberships
    FOR DELETE
    USING (public.get_user_org_role(org_id) = 'owner');

-- Users can leave organizations themselves (unless they're the only owner)
CREATE POLICY "Users can leave organizations"
    ON public.memberships
    FOR DELETE
    USING (
        auth.uid() = user_id
        AND NOT (
            role = 'owner'
            AND (
                SELECT COUNT(*)
                FROM public.memberships
                WHERE org_id = memberships.org_id
                AND role = 'owner'
            ) = 1
        )
    );
```

#### `projects` Table Policies

```sql
-- Users can view projects they own OR projects in organizations they belong to
CREATE POLICY "Users can view own or org projects"
    ON public.projects
    FOR SELECT
    USING (
        -- User-owned: org_id IS NULL and user_id matches
        (org_id IS NULL AND user_id = auth.uid())
        OR
        -- Organization-owned: org_id IS NOT NULL and user is member
        (org_id IS NOT NULL AND public.is_org_member(org_id))
    );

-- Users can create their own projects (user-owned) OR admins/owners can create org projects
CREATE POLICY "Users can create projects"
    ON public.projects
    FOR INSERT
    WITH CHECK (
        -- User-owned: user_id must match current user
        (org_id IS NULL AND user_id = auth.uid())
        OR
        -- Organization-owned: must be admin/owner and check limits
        (
            org_id IS NOT NULL 
            AND public.is_org_admin_or_owner(org_id)
            AND public.check_project_limit(org_id) -- See limit enforcement below
        )
    );

-- Users can update their own projects OR admins/owners can update org projects
CREATE POLICY "Users can update own or org projects"
    ON public.projects
    FOR UPDATE
    USING (
        -- User-owned: user_id must match
        (org_id IS NULL AND user_id = auth.uid())
        OR
        -- Organization-owned: must be admin/owner
        (org_id IS NOT NULL AND public.is_org_admin_or_owner(org_id))
    );

-- Users can delete their own projects OR admins/owners can delete org projects
CREATE POLICY "Users can delete own or org projects"
    ON public.projects
    FOR DELETE
    USING (
        -- User-owned: user_id must match
        (org_id IS NULL AND user_id = auth.uid())
        OR
        -- Organization-owned: must be admin/owner
        (org_id IS NOT NULL AND public.is_org_admin_or_owner(org_id))
    );
```

#### `usage_limits` Table Policies

```sql
-- All authenticated users can read usage limits
CREATE POLICY "Authenticated users can view usage limits"
    ON public.usage_limits
    FOR SELECT
    USING (auth.role() = 'authenticated');
```

#### `invitations` Table Policies

```sql
-- Users can view invitations for organizations they belong to
CREATE POLICY "Users can view org invitations"
    ON public.invitations
    FOR SELECT
    USING (public.is_org_member(org_id));

-- Only admins/owners can create invitations
CREATE POLICY "Admins can create invitations"
    ON public.invitations
    FOR INSERT
    WITH CHECK (
        public.is_org_admin_or_owner(org_id)
        AND public.check_member_limit(org_id) -- See limit enforcement below
    );

-- Only admins/owners can update invitations
CREATE POLICY "Admins can update invitations"
    ON public.invitations
    FOR UPDATE
    USING (public.is_org_admin_or_owner(org_id));

-- Only admins/owners can delete invitations
CREATE POLICY "Admins can delete invitations"
    ON public.invitations
    FOR DELETE
    USING (public.is_org_admin_or_owner(org_id));
```

---

## üí≥ PHASE 4: TIERED PRICING INTEGRATION

### 4.1 Subscription Sync (Stripe Webhook Handler)

**Supabase Edge Function:** `supabase/functions/stripe-webhook/index.ts`

```typescript
// Stripe Webhook Handler Pattern
// This should be implemented as a Supabase Edge Function

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const stripeSecret = Deno.env.get('STRIPE_SECRET_KEY')!;
const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;

const supabase = createClient(supabaseUrl, supabaseServiceKey);

// Map Stripe price IDs to semantic tier names
const PRICE_TO_TIER_MAP: Record<string, 'free' | 'pro' | 'enterprise'> = {
  'price_free': 'free',
  'price_pro_monthly': 'pro',
  'price_pro_yearly': 'pro',
  'price_enterprise_monthly': 'enterprise',
  'price_enterprise_yearly': 'enterprise',
};

serve(async (req) => {
  const signature = req.headers.get('stripe-signature');
  const body = await req.text();

  // Verify webhook signature (implement Stripe webhook verification)
  // ... verification logic ...

  const event = JSON.parse(body);

  if (event.type === 'customer.subscription.updated' || event.type === 'customer.subscription.created') {
    const subscription = event.data.object;
    const customerId = subscription.customer;
    const status = subscription.status;
    
    // Determine tier from subscription items
    const priceId = subscription.items.data[0]?.price.id;
    const tier = PRICE_TO_TIER_MAP[priceId] || 'free';

    // Update organization
    const { error } = await supabase
      .from('organizations')
      .update({
        subscription_tier: tier,
        subscription_status: status === 'active' ? 'active' : 
                           status === 'canceled' ? 'canceled' :
                           status === 'past_due' ? 'past_due' : 'trialing',
      })
      .eq('stripe_customer_id', customerId);

    if (error) {
      console.error('Error updating subscription:', error);
      return new Response(JSON.stringify({ error: error.message }), { status: 500 });
    }
  }

  if (event.type === 'customer.subscription.deleted') {
    const subscription = event.data.object;
    const customerId = subscription.customer;

    // Downgrade to free tier
    await supabase
      .from('organizations')
      .update({
        subscription_tier: 'free',
        subscription_status: 'canceled',
      })
      .eq('stripe_customer_id', customerId);
  }

  return new Response(JSON.stringify({ received: true }), { status: 200 });
});
```

### 4.2 Limit Enforcement Functions

#### `check_project_limit(org_id)` Function

**Purpose:** Enforce project limits before allowing new project creation.

```sql
-- Function to check if organization has reached project limit
-- NOTE: Only applies to organization-owned projects. User-owned projects (org_id = NULL) don't have limits.
CREATE OR REPLACE FUNCTION public.check_project_limit(org_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    current_tier TEXT;
    max_projects INTEGER;
    current_count INTEGER;
BEGIN
    -- Only check limits for organization-owned projects
    IF org_id IS NULL THEN
        RETURN TRUE; -- No limits for user-owned projects
    END IF;

    -- Get organization's tier
    SELECT subscription_tier INTO current_tier
    FROM public.organizations
    WHERE id = org_id;

    -- Get limit for tier
    SELECT max_projects INTO max_projects
    FROM public.usage_limits
    WHERE tier_id = current_tier;

    -- Unlimited tier (-1)
    IF max_projects = -1 THEN
        RETURN TRUE;
    END IF;

    -- Get current project count (only org-owned projects)
    SELECT COUNT(*) INTO current_count
    FROM public.projects
    WHERE org_id = check_project_limit.org_id
    AND status != 'deleted';

    -- Check if limit reached
    IF current_count >= max_projects THEN
        RAISE EXCEPTION 'Project limit reached. Current tier: %, Max projects: %, Current projects: %. Please upgrade your plan.', 
            current_tier, max_projects, current_count;
    END IF;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### `check_member_limit(org_id)` Function

**Purpose:** Enforce member limits before allowing new invitations.

```sql
-- Function to check if organization has reached member limit
CREATE OR REPLACE FUNCTION public.check_member_limit(org_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    current_tier TEXT;
    max_members INTEGER;
    current_count INTEGER;
BEGIN
    -- Get organization's tier
    SELECT subscription_tier INTO current_tier
    FROM public.organizations
    WHERE id = org_id;

    -- Get limit for tier
    SELECT max_members INTO max_members
    FROM public.usage_limits
    WHERE tier_id = current_tier;

    -- Unlimited tier (-1)
    IF max_members = -1 THEN
        RETURN TRUE;
    END IF;

    -- Get current member count
    SELECT COUNT(*) INTO current_count
    FROM public.memberships
    WHERE org_id = check_member_limit.org_id;

    -- Check if limit reached
    IF current_count >= max_members THEN
        RAISE EXCEPTION 'Member limit reached. Current tier: %, Max members: %, Current members: %. Please upgrade your plan.', 
            current_tier, max_members, current_count;
    END IF;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### `check_storage_limit(org_id, additional_bytes)` Function

**Purpose:** Enforce storage limits (example for file uploads).

```sql
-- Function to check if organization has reached storage limit
CREATE OR REPLACE FUNCTION public.check_storage_limit(org_id UUID, additional_bytes BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
    current_tier TEXT;
    max_storage BIGINT;
    current_usage BIGINT;
BEGIN
    -- Get organization's tier
    SELECT subscription_tier INTO current_tier
    FROM public.organizations
    WHERE id = org_id;

    -- Get limit for tier
    SELECT max_storage_bytes INTO max_storage
    FROM public.usage_limits
    WHERE tier_id = current_tier;

    -- Unlimited tier (-1)
    IF max_storage = -1 THEN
        RETURN TRUE;
    END IF;

    -- Get current storage usage (example - adjust based on your storage table)
    -- SELECT COALESCE(SUM(file_size), 0) INTO current_usage
    -- FROM public.files
    -- WHERE org_id = check_storage_limit.org_id;
    
    -- For now, assume 0
    current_usage := 0;

    -- Check if limit would be exceeded
    IF (current_usage + additional_bytes) > max_storage THEN
        RAISE EXCEPTION 'Storage limit would be exceeded. Current tier: %, Max storage: % bytes, Current usage: % bytes, Additional: % bytes. Please upgrade your plan.', 
            current_tier, max_storage, current_usage, additional_bytes;
    END IF;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## üìù PHASE 5: TYPESCRIPT INTERFACES

### 5.1 Database Types (Generated from Supabase)

```typescript
// types/database.types.ts
// These types should be generated using: npx supabase gen types typescript --project-id <project-id>

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string
          full_name: string | null
          avatar_url: string | null
          onboarding_status: 'pending' | 'completed'
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          full_name?: string | null
          avatar_url?: string | null
          onboarding_status?: 'pending' | 'completed'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          full_name?: string | null
          avatar_url?: string | null
          onboarding_status?: 'pending' | 'completed'
          created_at?: string
          updated_at?: string
        }
      }
      organizations: {
        Row: {
          id: string
          name: string
          slug: string
          stripe_customer_id: string | null
          subscription_tier: 'free' | 'pro' | 'enterprise'
          subscription_status: 'active' | 'canceled' | 'past_due' | 'trialing'
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          name: string
          slug: string
          stripe_customer_id?: string | null
          subscription_tier?: 'free' | 'pro' | 'enterprise'
          subscription_status?: 'active' | 'canceled' | 'past_due' | 'trialing'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          name?: string
          slug?: string
          stripe_customer_id?: string | null
          subscription_tier?: 'free' | 'pro' | 'enterprise'
          subscription_status?: 'active' | 'canceled' | 'past_due' | 'trialing'
          created_at?: string
          updated_at?: string
        }
      }
      memberships: {
        Row: {
          id: string
          user_id: string
          org_id: string
          role: 'owner' | 'admin' | 'member'
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          org_id: string
          role?: 'owner' | 'admin' | 'member'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          org_id?: string
          role?: 'owner' | 'admin' | 'member'
          created_at?: string
          updated_at?: string
        }
      }
      usage_limits: {
        Row: {
          id: string
          tier_id: 'free' | 'pro' | 'enterprise'
          max_projects: number
          max_storage_bytes: number
          can_invite_members: boolean
          max_members: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          tier_id: 'free' | 'pro' | 'enterprise'
          max_projects: number
          max_storage_bytes: number
          can_invite_members: boolean
          max_members: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          tier_id?: 'free' | 'pro' | 'enterprise'
          max_projects?: number
          max_storage_bytes?: number
          can_invite_members?: boolean
          max_members?: number
          created_at?: string
          updated_at?: string
        }
      }
      projects: {
        Row: {
          id: string
          user_id: string
          org_id: string | null
          name: string
          description: string | null
          status: 'active' | 'archived' | 'deleted'
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          org_id?: string | null
          name: string
          description?: string | null
          status?: 'active' | 'archived' | 'deleted'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          org_id?: string | null
          name?: string
          description?: string | null
          status?: 'active' | 'archived' | 'deleted'
          created_at?: string
          updated_at?: string
        }
      }
      invitations: {
        Row: {
          id: string
          org_id: string
          email: string
          role: 'owner' | 'admin' | 'member'
          invited_by: string
          token: string
          status: 'pending' | 'accepted' | 'expired' | 'revoked'
          expires_at: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          org_id: string
          email: string
          role?: 'owner' | 'admin' | 'member'
          invited_by: string
          token?: string
          status?: 'pending' | 'accepted' | 'expired' | 'revoked'
          expires_at?: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          org_id?: string
          email?: string
          role?: 'owner' | 'admin' | 'member'
          invited_by?: string
          token?: string
          status?: 'pending' | 'accepted' | 'expired' | 'revoked'
          expires_at?: string
          created_at?: string
          updated_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      is_org_member: {
        Args: {
          org_id: string
        }
        Returns: boolean
      }
      get_user_org_role: {
        Args: {
          org_id: string
        }
        Returns: string | null
      }
      is_org_admin_or_owner: {
        Args: {
          org_id: string
        }
        Returns: boolean
      }
      check_project_limit: {
        Args: {
          org_id: string
        }
        Returns: boolean
      }
      check_member_limit: {
        Args: {
          org_id: string
        }
        Returns: boolean
      }
      check_storage_limit: {
        Args: {
          org_id: string
          additional_bytes: number
        }
        Returns: boolean
      }
    }
    Enums: {
      [_ in never]: never
    }
  }
}

// Type aliases for convenience
export type Profile = Database['public']['Tables']['profiles']['Row']
export type Organization = Database['public']['Tables']['organizations']['Row']
export type Membership = Database['public']['Tables']['memberships']['Row']
export type UsageLimit = Database['public']['Tables']['usage_limits']['Row']
export type Project = Database['public']['Tables']['projects']['Row']
export type Invitation = Database['public']['Tables']['invitations']['Row']

export type SubscriptionTier = 'free' | 'pro' | 'enterprise'
export type MembershipRole = 'owner' | 'admin' | 'member'
export type InvitationStatus = 'pending' | 'accepted' | 'expired' | 'revoked'
```

---

## üë• PHASE 6: INVITATION FLOW

### 6.1 Creating an Invitation

**Frontend Pattern:**

```typescript
// utils/invitations.ts
import { SupabaseClient } from '@supabase/supabase-js'
import { Database } from '@/types/database.types'

export async function createInvitation(
  supabase: SupabaseClient<Database>,
  orgId: string,
  email: string,
  role: MembershipRole = 'member'
) {
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    throw new Error('User not authenticated')
  }

  // Check if user is admin/owner
  const { data: membership } = await supabase
    .from('memberships')
    .select('role')
    .eq('org_id', orgId)
    .eq('user_id', user.id)
    .single()

  if (!membership || !['admin', 'owner'].includes(membership.role)) {
    throw new Error('Insufficient permissions')
  }

  // Create invitation
  const { data, error } = await supabase
    .from('invitations')
    .insert({
      org_id: orgId,
      email: email.toLowerCase().trim(),
      role,
      invited_by: user.id,
    })
    .select()
    .single()

  if (error) {
    throw error
  }

  // Send invitation email (implement your email service)
  await sendInvitationEmail(data.email, data.token, data.org_id)

  return data
}
```

### 6.2 Accepting an Invitation

**Frontend Pattern:**

```typescript
// utils/invitations.ts (continued)

export async function acceptInvitation(
  supabase: SupabaseClient<Database>,
  token: string
) {
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    throw new Error('User must be authenticated to accept invitation')
  }

  // Find invitation
  const { data: invitation, error: inviteError } = await supabase
    .from('invitations')
    .select('*')
    .eq('token', token)
    .eq('status', 'pending')
    .single()

  if (inviteError || !invitation) {
    throw new Error('Invitation not found or already used')
  }

  // Check expiration
  if (new Date(invitation.expires_at) < new Date()) {
    await supabase
      .from('invitations')
      .update({ status: 'expired' })
      .eq('id', invitation.id)
    
    throw new Error('Invitation has expired')
  }

  // Verify email matches
  if (invitation.email !== user.email) {
    throw new Error('Invitation email does not match your account')
  }

  // Check if already a member
  const { data: existingMembership } = await supabase
    .from('memberships')
    .select('id')
    .eq('org_id', invitation.org_id)
    .eq('user_id', user.id)
    .single()

  if (existingMembership) {
    // Already a member, just mark invitation as accepted
    await supabase
      .from('invitations')
      .update({ status: 'accepted' })
      .eq('id', invitation.id)
    
    return { alreadyMember: true, orgId: invitation.org_id }
  }

  // Create membership
  const { error: membershipError } = await supabase
    .from('memberships')
    .insert({
      user_id: user.id,
      org_id: invitation.org_id,
      role: invitation.role,
    })

  if (membershipError) {
    throw membershipError
  }

  // Mark invitation as accepted
  await supabase
    .from('invitations')
    .update({ status: 'accepted' })
    .eq('id', invitation.id)

  return { orgId: invitation.org_id }
}
```

### 6.3 Revoking an Invitation

```typescript
export async function revokeInvitation(
  supabase: SupabaseClient<Database>,
  invitationId: string,
  orgId: string
) {
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    throw new Error('User not authenticated')
  }

  // Verify permissions
  const { data: membership } = await supabase
    .from('memberships')
    .select('role')
    .eq('org_id', orgId)
    .eq('user_id', user.id)
    .single()

  if (!membership || !['admin', 'owner'].includes(membership.role)) {
    throw new Error('Insufficient permissions')
  }

  // Revoke invitation
  const { error } = await supabase
    .from('invitations')
    .update({ status: 'revoked' })
    .eq('id', invitationId)
    .eq('org_id', orgId)

  if (error) {
    throw error
  }
}
```

---

## üöÄ DEPLOYMENT CHECKLIST

### Database Setup

1. ‚úÖ Run all SQL schema creation scripts in order
2. ‚úÖ Verify all RLS policies are enabled
3. ‚úÖ Test helper functions (`is_org_member`, etc.)
4. ‚úÖ Insert default `usage_limits` data
5. ‚úÖ Test trigger `handle_new_user()` with a test signup

### Security Verification

1. ‚úÖ Verify RLS is enabled on all tables
2. ‚úÖ Test that users cannot access other organizations' data
3. ‚úÖ Test that non-admins cannot create/update/delete resources
4. ‚úÖ Verify limit enforcement functions raise exceptions correctly

### Integration Setup

1. ‚úÖ Configure Stripe webhook endpoint
2. ‚úÖ Set up Supabase Edge Function for webhook handler
3. ‚úÖ Map Stripe price IDs to tier names
4. ‚úÖ Test subscription sync flow

### Frontend Integration

1. ‚úÖ Implement `useCurrentOrganization()` hook
2. ‚úÖ Persist active organization in localStorage
3. ‚úÖ Filter all queries by `org_id`
4. ‚úÖ Implement invitation flow UI
5. ‚úÖ Add limit checking UI feedback

---

## üìö ADDITIONAL NOTES

### Query Patterns

**Always filter by org_id:**
```typescript
// ‚úÖ CORRECT
const { data } = await supabase
  .from('projects')
  .select('*')
  .eq('org_id', activeOrgId)

// ‚ùå WRONG - RLS will block, but don't rely on it
const { data } = await supabase
  .from('projects')
  .select('*')
```

### Migration Strategy

When adding new resource tables:
1. Include both `user_id UUID NOT NULL REFERENCES auth.users(id)` AND `org_id UUID REFERENCES organizations(id)` (nullable)
2. Add constraint: `CHECK ((org_id IS NULL AND user_id IS NOT NULL) OR (org_id IS NOT NULL))`
3. Create RLS policies that support both patterns (see `projects` table policies above)
4. Add indexes on both `user_id` and `org_id` (partial index on `org_id` where `org_id IS NOT NULL`)
5. Add limit checking if the resource is tier-limited (only for org-owned resources)
6. Update TypeScript types to reflect nullable `org_id`

### Performance Considerations

- Index all `org_id` foreign keys
- Consider materialized views for organization statistics
- Use database functions for complex limit checks (not client-side)
- Cache `usage_limits` table data (rarely changes)

---

---

## üéØ WHEN TO USE ORGANIZATIONS VS INDIVIDUAL OWNERSHIP

### Use Individual Ownership (`org_id = NULL`) when:

- **Building a simple shop** with individual sellers (e.g., Etsy-style marketplace)
- **Creating a personal productivity app** where users manage their own data
- **Users don't need to collaborate** or share resources
- **Each user manages their own resources independently** (e.g., personal todo lists, individual portfolios)
- **Building a B2C product** where users are consumers, not teams
- **You want the simplest possible architecture** without team features

**Example Use Cases:**
- Personal finance tracker
- Individual seller marketplace
- Personal blog platform
- Individual portfolio sites
- Personal note-taking app

### Use Organizations (`org_id IS NOT NULL`) when:

- **Building a team collaboration tool** (e.g., project management, team chat)
- **Multiple users need to share resources** (e.g., shared documents, team calendars)
- **You need team billing/subscriptions** (Stripe customer per organization)
- **You need role-based permissions within teams** (admin, member, viewer)
- **Building a B2B SaaS product** where companies are the customers
- **Resources belong to a company/team**, not individual users

**Example Use Cases:**
- Team project management tool
- Company knowledge base
- Team calendar/scheduling
- Enterprise SaaS products
- Multi-user dashboards

### Hybrid Approach:

- **Allow both patterns!** Some resources can be user-owned, others org-owned
- **Let users choose** when creating resources (e.g., "Create personal project" vs "Create team project")
- **Support migration** from individual to organization (set `org_id` when user joins/creates org)
- **Use the same table schema** with nullable `org_id` - RLS handles both automatically

**Example Hybrid Use Case:**
- A project management tool where users can have personal projects (`org_id = NULL`) and team projects (`org_id IS NOT NULL`)
- An e-commerce platform where individual sellers own their shops (`org_id = NULL`) but can optionally join seller organizations (`org_id IS NOT NULL`)

---

**END OF DOCUMENTATION**
