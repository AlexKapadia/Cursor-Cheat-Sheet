# MongoDB Backend Architecture: Source of Truth

**SaaS Application Architecture**  
**Data Layer:** MongoDB | **Auth Layer:** Supabase

---

## ‚ö†Ô∏è CRITICAL ARCHITECTURE PRINCIPLES

### The "Tenant Isolation" Rule

1. **Application-Level Security:** Unlike Postgres RLS, we must enforce security in the API Middleware. Every query must be scoped to an `organizationId`.

2. **The "Supabase-Mongo" Bridge:** 
   - Supabase is used **strictly** for Authentication (JWTs)
   - MongoDB is used for **all** user data and business logic
   - Never store business data in Supabase tables

3. **Compound Indexing:** Performance is dead without indexes. Every schema that belongs to a tenant must have a compound index starting with `organizationId`.

---

## PHASE 1: DOCUMENT SCHEMAS

### 1. Identity & Tenancy (The Core)

#### User Collection

**Purpose:** Maps Supabase Auth users to MongoDB documents. Uses Supabase UUID as `_id`.

```typescript
// Mongoose Schema
const UserSchema = new Schema({
  _id: {
    type: String,
    required: true,
    // CRITICAL: This must match Supabase Auth User UUID
    // Do NOT use auto-generated ObjectId
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
  },
  currentOrgId: {
    type: Schema.Types.ObjectId,
    ref: 'Organization',
    // Tracks the user's active organization context
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
}, {
  _id: false, // Disable auto _id generation
  timestamps: true,
});

// Indexes
UserSchema.index({ email: 1 }, { unique: true });
UserSchema.index({ currentOrgId: 1 });
```

**Prisma Schema Alternative:**
```prisma
model User {
  id          String   @id // Supabase UUID
  email       String   @unique
  currentOrgId String? // Organization ObjectId as String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  memberships Member[]
  
  @@index([email])
  @@index([currentOrgId])
}
```

---

#### Organization Collection

**Purpose:** Represents a tenant workspace with subscription and limits.

```typescript
// Mongoose Schema
const OrganizationSchema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true,
  },
  subscription: {
    plan: {
      type: String,
      enum: ['free', 'starter', 'pro', 'enterprise'],
      default: 'free',
      required: true,
    },
    status: {
      type: String,
      enum: ['active', 'canceled', 'past_due', 'trialing'],
      default: 'active',
      required: true,
    },
    stripeId: {
      type: String,
      sparse: true, // Allow null for free plans
    },
    currentPeriodEnd: {
      type: Date,
    },
  },
  limits: {
    maxProjects: {
      type: Number,
      default: 1,
    },
    maxStorageGB: {
      type: Number,
      default: 1,
    },
    aiCredits: {
      type: Number,
      default: 0,
    },
    maxMembers: {
      type: Number,
      default: 1,
    },
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

// Indexes
OrganizationSchema.index({ 'subscription.stripeId': 1 }, { sparse: true });
OrganizationSchema.index({ 'subscription.status': 1 });
```

**Prisma Schema Alternative:**
```prisma
model Organization {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  subscription Subscription
  limits    Limits
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  members   Member[]
  projects  Project[]
  
  @@index([subscription.status])
}

type Subscription {
  plan              String
  status            String
  stripeId          String?
  currentPeriodEnd  DateTime?
}

type Limits {
  maxProjects   Int
  maxStorageGB  Int
  aiCredits     Int
  maxMembers    Int
}
```

---

#### Member Collection

**Purpose:** Junction table for User-Organization relationships with roles.

```typescript
// Mongoose Schema
const MemberSchema = new Schema({
  userId: {
    type: String,
    required: true,
    ref: 'User',
    // References User._id (Supabase UUID)
  },
  orgId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Organization',
  },
  role: {
    type: String,
    enum: ['owner', 'admin', 'editor', 'viewer'],
    default: 'viewer',
    required: true,
  },
  invitedBy: {
    type: String,
    ref: 'User',
  },
  joinedAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

// CRITICAL: Compound unique index prevents duplicate memberships
MemberSchema.index({ userId: 1, orgId: 1 }, { unique: true });

// Performance indexes
MemberSchema.index({ orgId: 1, role: 1 });
MemberSchema.index({ userId: 1 });
```

**Prisma Schema Alternative:**
```prisma
model Member {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   // Supabase UUID
  orgId     String   @db.ObjectId
  role      String
  invitedBy String?
  joinedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user         User         @relation(fields: [userId], references: [id])
  organization Organization @relation(fields: [orgId], references: [id])
  
  @@unique([userId, orgId])
  @@index([orgId, role])
  @@index([userId])
}
```

---

### 2. Business Data (Example Resource)

#### Project Collection

**Purpose:** Example business resource demonstrating tenant-scoped data.

```typescript
// Mongoose Schema
const ProjectSchema = new Schema({
  orgId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Organization',
    // MANDATORY FIELD: Every query must filter by this
  },
  title: {
    type: String,
    required: true,
    trim: true,
  },
  description: {
    type: String,
  },
  data: {
    type: Schema.Types.Mixed,
    // Flexible JSON structure for project-specific data
  },
  createdBy: {
    type: String,
    required: true,
    ref: 'User',
  },
  status: {
    type: String,
    enum: ['draft', 'active', 'archived'],
    default: 'draft',
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

// CRITICAL: Compound index starting with orgId for tenant isolation
ProjectSchema.index({ orgId: 1, _id: 1 });
ProjectSchema.index({ orgId: 1, status: 1 });
ProjectSchema.index({ orgId: 1, createdAt: -1 });
ProjectSchema.index({ createdBy: 1, orgId: 1 });
```

**Prisma Schema Alternative:**
```prisma
model Project {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  orgId       String   @db.ObjectId
  title       String
  description String?
  data        Json
  createdBy   String
  status      String   @default("draft")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  organization Organization @relation(fields: [orgId], references: [id])
  
  @@index([orgId, id])
  @@index([orgId, status])
  @@index([orgId, createdAt(sort: Desc)])
  @@index([createdBy, orgId])
}
```

---

## PHASE 2: AUTHENTICATION SYNC (THE BRIDGE)

### 1. The "Sync" Webhook

**Purpose:** Synchronize Supabase Auth events with MongoDB User collection.

#### Next.js API Route: `/api/auth/hook`

```typescript
// app/api/auth/hook/route.ts (Next.js App Router)
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { connectDB, User, Organization, Member } from '@/lib/mongodb';

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY! // Service key for admin operations
);

// Verify webhook signature from Supabase
async function verifyWebhookSignature(
  request: NextRequest,
  payload: string
): Promise<boolean> {
  const signature = request.headers.get('x-supabase-signature');
  // Implement signature verification logic
  // Supabase sends HMAC SHA256 signature
  return true; // Simplified - implement actual verification
}

export async function POST(request: NextRequest) {
  try {
    const payload = await request.text();
    
    // Verify webhook signature
    const isValid = await verifyWebhookSignature(request, payload);
    if (!isValid) {
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 401 }
      );
    }

    const event = JSON.parse(payload);
    
    // Handle user creation event
    if (event.type === 'INSERT' && event.table === 'auth.users') {
      const supabaseUser = event.record;
      
      await connectDB();
      
      // Create User document with Supabase UUID as _id
      const user = new User({
        _id: supabaseUser.id, // CRITICAL: Use Supabase UUID
        email: supabaseUser.email,
      });
      await user.save();
      
      // Create default organization ("My Workspace")
      const organization = new Organization({
        name: `${supabaseUser.email?.split('@')[0]}'s Workspace`,
        subscription: {
          plan: 'free',
          status: 'active',
        },
        limits: {
          maxProjects: 1,
          maxStorageGB: 1,
          aiCredits: 0,
          maxMembers: 1,
        },
      });
      await organization.save();
      
      // Create Member relationship (owner role)
      const member = new Member({
        userId: supabaseUser.id,
        orgId: organization._id,
        role: 'owner',
      });
      await member.save();
      
      // Set user's current organization
      user.currentOrgId = organization._id;
      await user.save();
      
      return NextResponse.json({
        success: true,
        userId: user._id,
        orgId: organization._id,
      });
    }
    
    // Handle user deletion event
    if (event.type === 'DELETE' && event.table === 'auth.users') {
      const supabaseUserId = event.old_record.id;
      
      await connectDB();
      
      // Soft delete or hard delete based on business logic
      // Option 1: Hard delete
      await User.findByIdAndDelete(supabaseUserId);
      
      // Option 2: Soft delete (recommended)
      // await User.findByIdAndUpdate(supabaseUserId, { deletedAt: new Date() });
      
      return NextResponse.json({ success: true });
    }
    
    return NextResponse.json({ message: 'Event not handled' }, { status: 200 });
  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

#### Supabase Webhook Configuration

1. Go to Supabase Dashboard ‚Üí Database ‚Üí Webhooks
2. Create new webhook on `auth.users` table
3. Set trigger events: `INSERT`, `UPDATE`, `DELETE`
4. Set webhook URL: `https://yourdomain.com/api/auth/hook`
5. Add secret header for signature verification

---

### 2. The "Context" Middleware

**Purpose:** Verify JWT, extract user context, and enforce tenant access.

#### Helper Function: `getTenantContext`

```typescript
// lib/middleware/tenant-context.ts
import { createClient } from '@supabase/supabase-js';
import { connectDB, Member, User } from '@/lib/mongodb';
import { NextRequest } from 'next/server';

interface TenantContext {
  userId: string;
  orgId: string;
  role: string;
  user: any;
}

export async function getTenantContext(
  request: NextRequest
): Promise<TenantContext> {
  // 1. Extract and verify Supabase JWT
  const authHeader = request.headers.get('authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Error('Missing or invalid authorization header');
  }

  const token = authHeader.substring(7);
  const supabase = createClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_ANON_KEY!
  );

  const { data: { user: supabaseUser }, error } = await supabase.auth.getUser(token);
  
  if (error || !supabaseUser) {
    throw new Error('Invalid or expired token');
  }

  const userId = supabaseUser.id;

  // 2. Get organization ID from header or query param
  const orgId = request.headers.get('x-organization-id') || 
                request.nextUrl.searchParams.get('orgId');

  if (!orgId) {
    throw new Error('Organization ID required');
  }

  await connectDB();

  // 3. Verify user has access to this organization
  const member = await Member.findOne({
    userId: userId,
    orgId: orgId,
  });

  if (!member) {
    throw new Error('403 Forbidden: User does not have access to this organization');
  }

  // 4. Get user document
  const user = await User.findById(userId);
  if (!user) {
    throw new Error('User not found in database');
  }

  return {
    userId,
    orgId,
    role: member.role,
    user,
  };
}
```

#### API Route Middleware Wrapper

```typescript
// lib/middleware/with-tenant.ts
import { NextRequest, NextResponse } from 'next/server';
import { getTenantContext } from './tenant-context';

export function withTenant(
  handler: (req: NextRequest, context: TenantContext) => Promise<NextResponse>
) {
  return async (req: NextRequest) => {
    try {
      const context = await getTenantContext(req);
      return await handler(req, context);
    } catch (error: any) {
      if (error.message.includes('403') || error.message.includes('Forbidden')) {
        return NextResponse.json(
          { error: 'Forbidden: Access denied' },
          { status: 403 }
        );
      }
      if (error.message.includes('Invalid') || error.message.includes('expired')) {
        return NextResponse.json(
          { error: 'Unauthorized' },
          { status: 401 }
        );
      }
      return NextResponse.json(
        { error: error.message || 'Internal server error' },
        { status: 500 }
      );
    }
  };
}
```

#### Usage in API Routes

```typescript
// app/api/projects/route.ts
import { withTenant } from '@/lib/middleware/with-tenant';
import { Project } from '@/lib/mongodb';
import { NextRequest, NextResponse } from 'next/server';

export const GET = withTenant(async (req: NextRequest, context) => {
  // context.orgId is guaranteed to be valid and user has access
  const projects = await Project.find({ orgId: context.orgId })
    .sort({ createdAt: -1 })
    .limit(100);
  
  return NextResponse.json({ projects });
});

export const POST = withTenant(async (req: NextRequest, context) => {
  const body = await req.json();
  
  // CRITICAL: Always set orgId from context, never from request body
  const project = new Project({
    ...body,
    orgId: context.orgId, // Enforced from middleware
    createdBy: context.userId,
  });
  
  await project.save();
  
  return NextResponse.json({ project }, { status: 201 });
});
```

---

## PHASE 3: TIERED PRICING & FEATURE GATING

### 1. Storing Limits (Embedded on Organization)

**Principle:** Store limits directly on the Organization document for fast lookups. No joins required.

```typescript
// Example Organization document structure
{
  "_id": ObjectId("..."),
  "name": "Acme Corp",
  "subscription": {
    "plan": "pro",
    "status": "active",
    "stripeId": "sub_xxx",
    "currentPeriodEnd": ISODate("2024-12-31")
  },
  "limits": {
    "maxProjects": 50,
    "maxStorageGB": 100,
    "aiCredits": 1000,
    "maxMembers": 10
  }
}
```

### 2. Feature Gating Helper

```typescript
// lib/features/check-limits.ts
import { Organization } from '@/lib/mongodb';

interface LimitCheck {
  allowed: boolean;
  reason?: string;
  current?: number;
  limit?: number;
}

export async function checkProjectLimit(orgId: string): Promise<LimitCheck> {
  const org = await Organization.findById(orgId);
  if (!org) {
    return { allowed: false, reason: 'Organization not found' };
  }

  const currentCount = await Project.countDocuments({ orgId });
  const limit = org.limits.maxProjects;

  if (currentCount >= limit) {
    return {
      allowed: false,
      reason: 'Project limit reached',
      current: currentCount,
      limit,
    };
  }

  return { allowed: true, current: currentCount, limit };
}

export async function checkStorageLimit(
  orgId: string,
  additionalGB: number
): Promise<LimitCheck> {
  const org = await Organization.findById(orgId);
  if (!org) {
    return { allowed: false, reason: 'Organization not found' };
  }

  // Calculate current storage usage (implement based on your storage tracking)
  const currentStorage = await calculateStorageUsage(orgId);
  const limit = org.limits.maxStorageGB;

  if (currentStorage + additionalGB > limit) {
    return {
      allowed: false,
      reason: 'Storage limit exceeded',
      current: currentStorage,
      limit,
    };
  }

  return { allowed: true, current: currentStorage, limit };
}

export async function checkAICredits(orgId: string, credits: number): Promise<LimitCheck> {
  const org = await Organization.findById(orgId);
  if (!org) {
    return { allowed: false, reason: 'Organization not found' };
  }

  if (org.limits.aiCredits < credits) {
    return {
      allowed: false,
      reason: 'Insufficient AI credits',
      current: org.limits.aiCredits,
      limit: credits,
    };
  }

  return { allowed: true, current: org.limits.aiCredits };
}
```

### 3. Usage in API Routes

```typescript
// app/api/projects/route.ts
export const POST = withTenant(async (req: NextRequest, context) => {
  // Check limits before creating
  const limitCheck = await checkProjectLimit(context.orgId);
  if (!limitCheck.allowed) {
    return NextResponse.json(
      { 
        error: limitCheck.reason,
        current: limitCheck.current,
        limit: limitCheck.limit,
      },
      { status: 403 }
    );
  }

  const body = await req.json();
  const project = new Project({
    ...body,
    orgId: context.orgId,
    createdBy: context.userId,
  });
  
  await project.save();
  
  return NextResponse.json({ project }, { status: 201 });
});
```

### 4. Subscription Plan Definitions

```typescript
// lib/subscriptions/plans.ts
export const SUBSCRIPTION_PLANS = {
  free: {
    maxProjects: 1,
    maxStorageGB: 1,
    aiCredits: 0,
    maxMembers: 1,
  },
  starter: {
    maxProjects: 5,
    maxStorageGB: 10,
    aiCredits: 100,
    maxMembers: 3,
  },
  pro: {
    maxProjects: 50,
    maxStorageGB: 100,
    aiCredits: 1000,
    maxMembers: 10,
  },
  enterprise: {
    maxProjects: -1, // Unlimited
    maxStorageGB: -1,
    aiCredits: -1,
    maxMembers: -1,
  },
};

// Update organization limits when subscription changes
export async function updateOrganizationLimits(
  orgId: string,
  plan: keyof typeof SUBSCRIPTION_PLANS
) {
  const limits = SUBSCRIPTION_PLANS[plan];
  
  await Organization.findByIdAndUpdate(orgId, {
    'subscription.plan': plan,
    limits: limits,
  });
}
```

---

## PHASE 4: QUERY PATTERNS & BEST PRACTICES

### 1. Always Scope by Organization

```typescript
// ‚úÖ CORRECT: Always filter by orgId
const projects = await Project.find({ 
  orgId: context.orgId,
  status: 'active' 
});

// ‚ùå WRONG: Missing orgId filter
const projects = await Project.find({ status: 'active' });
```

### 2. Use Compound Indexes for Queries

```typescript
// Query pattern: orgId + status
// Index: { orgId: 1, status: 1 }
const activeProjects = await Project.find({
  orgId: context.orgId,
  status: 'active',
}).sort({ createdAt: -1 });

// Query pattern: orgId + date range
// Index: { orgId: 1, createdAt: -1 }
const recentProjects = await Project.find({
  orgId: context.orgId,
  createdAt: { $gte: startDate, $lte: endDate },
});
```

### 3. Aggregation Pipelines with Tenant Isolation

```typescript
// Always start aggregation with $match on orgId
const stats = await Project.aggregate([
  { $match: { orgId: context.orgId } }, // CRITICAL: First stage
  { $group: {
    _id: '$status',
    count: { $sum: 1 },
    totalSize: { $sum: '$size' },
  }},
]);
```

### 4. Update Operations

```typescript
// Always include orgId in update queries
await Project.updateOne(
  { 
    _id: projectId,
    orgId: context.orgId, // Prevent cross-tenant updates
  },
  { $set: { title: newTitle } }
);
```

---

## PHASE 5: SECURITY CHECKLIST

### ‚úÖ Mandatory Security Practices

- [ ] **Every query** includes `orgId` filter
- [ ] **Every update** includes `orgId` in where clause
- [ ] **Every delete** includes `orgId` in where clause
- [ ] **JWT verification** happens in middleware before any DB access
- [ ] **Member relationship** verified before granting access
- [ ] **Compound indexes** exist on all tenant-scoped collections
- [ ] **Webhook signature** verified for Supabase events
- [ ] **User input** never trusted for `orgId` (always from context)

### üîí Security Anti-Patterns to Avoid

```typescript
// ‚ùå NEVER: Trust orgId from request body
const { orgId, ...data } = req.body;
await Project.create({ orgId, ...data });

// ‚úÖ ALWAYS: Use orgId from verified context
await Project.create({ orgId: context.orgId, ...data });

// ‚ùå NEVER: Query without orgId filter
await Project.findById(id);

// ‚úÖ ALWAYS: Include orgId in query
await Project.findOne({ _id: id, orgId: context.orgId });
```

---

## PHASE 6: PERFORMANCE OPTIMIZATION

### Index Strategy Summary

```typescript
// User Collection
UserSchema.index({ email: 1 }, { unique: true });
UserSchema.index({ currentOrgId: 1 });

// Organization Collection
OrganizationSchema.index({ 'subscription.stripeId': 1 }, { sparse: true });
OrganizationSchema.index({ 'subscription.status': 1 });

// Member Collection
MemberSchema.index({ userId: 1, orgId: 1 }, { unique: true });
MemberSchema.index({ orgId: 1, role: 1 });
MemberSchema.index({ userId: 1 });

// Project Collection (Example)
ProjectSchema.index({ orgId: 1, _id: 1 });
ProjectSchema.index({ orgId: 1, status: 1 });
ProjectSchema.index({ orgId: 1, createdAt: -1 });
ProjectSchema.index({ createdBy: 1, orgId: 1 });
```

### Query Performance Tips

1. **Always start compound indexes with `orgId`** - Enables efficient tenant isolation
2. **Use projection** to limit returned fields: `.select('title status')`
3. **Use pagination** for large result sets: `.skip(offset).limit(limit)`
4. **Monitor slow queries** using MongoDB profiler
5. **Use `explain()`** to verify index usage

---

## PHASE 7: ENVIRONMENT VARIABLES

```env
# Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# MongoDB
MONGODB_URI=mongodb+srv://user:pass@cluster.mongodb.net/dbname?retryWrites=true&w=majority

# Webhook Security
WEBHOOK_SECRET=your-webhook-secret
```

---

## SUMMARY

This architecture provides:

1. **Secure Multi-Tenancy:** Application-level isolation with mandatory `orgId` scoping
2. **Auth Bridge:** Seamless sync between Supabase Auth and MongoDB data
3. **Performance:** Compound indexes optimized for tenant-scoped queries
4. **Feature Gating:** Embedded limits on Organization documents for fast checks
5. **Scalability:** MongoDB's flexible schema supports rapid feature development

**Remember:** The tenant isolation rule is non-negotiable. Every query, update, and delete must be scoped to an `organizationId` verified through the middleware context.
